{
 "parentDoc": "5db19f9975818c0034428efb", 
 "excerpt": "", 
 "api": {
  "url": "", 
  "params": [], 
  "results": {
   "codes": [
    {
     "status": 200, 
     "code": "{}", 
     "name": "", 
     "language": "json"
    }, 
    {
     "status": 400, 
     "code": "{}", 
     "name": "", 
     "language": "json"
    }
   ]
  }, 
  "auth": "required", 
  "method": "get"
 }, 
 "updatedAt": "2019-11-11T21:55:03.761Z", 
 "sync_unique": "", 
 "id": "5db1ba63ff6cc8005f710883", 
 "createdAt": "2019-10-24T14:51:15.932Z", 
 "category": "5db19f199332b800310886f8", 
 "title": "Creating A Bloom Filter", 
 "next": {
  "pages": [
   {
    "category": "Core Examples", 
    "icon": "file-text-o", 
    "type": "doc", 
    "slug": "core-examples-p2p-network-evaluating-a-bloom-filter", 
    "name": "Evaluating A Bloom Filter"
   }
  ], 
  "description": ""
 }, 
 "version": "5daf2e65f4109c0040fd51e5", 
 "hidden": false, 
 "type": "basic", 
 "metadata": {
  "image": [], 
  "description": "", 
  "title": ""
 }, 
 "body": "In this section, we'll use variable names that correspond to the field names in the [`filterload` message documentation](core-ref-p2p-network-control-messages#section-filterload). Each code block precedes the paragraph describing it.\n\n``` python\n#!/usr/bin/env python\n\nBYTES_MAX = 36000\nFUNCS_MAX = 50\n\nnFlags = 0\n```\n\nWe start by setting some maximum values defined in [BIP37](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki): the maximum number of bytes allowed in a filter and the maximum number of hash functions used to hash each piece of data.  We also set nFlags to zero, indicating we don't want the remote node to update the filter for us. (We won't use nFlags again in the sample program, but real programs will need to use it.)\n\n``` python\nn = 1\np = 0.0001\n```\n\nWe define the number (n) of elements we plan to insert into the filter and the false positive rate (p) we want to help protect our privacy. For this example, we will set *n* to one element and *p* to a rate of 1-in-10,000 to produce a small and precise filter for illustration purposes. In actual use, your filters will probably be much larger.\n\n``` python\nfrom math import log\nnFilterBytes = int(min((-1 / log(2)**2 * n * log(p)) / 8, BYTES_MAX))\nnHashFuncs = int(min(nFilterBytes * 8 / n * log(2), FUNCS_MAX))\n\nfrom bitarray import bitarray  # from pypi.python.org/pypi/bitarray\nvData = nFilterBytes * 8 * bitarray('0', endian=\"little\")\n```\n\nUsing the formula described in [BIP37](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki), we calculate the ideal size of the filter (in bytes) and the ideal number of hash functions to use. Both are truncated down to the nearest whole number and both are also constrained to the maximum values we defined earlier. The results of this particular fixed computation are 2 filter bytes and 11 hash functions. We then use *nFilterBytes* to create a little-endian bit array of the appropriate size.\n\n``` python\nnTweak = 0\n```\n\nWe also should choose a value for *nTweak*.  In this case, we'll simply use zero.\n\n``` python\nimport pyhash  # from https://github.com/flier/pyfasthash\nmurmur3 = pyhash.murmur3_32()\n\ndef bloom_hash(nHashNum, data):\n    seed = (nHashNum * 0xfba4c795 + nTweak) & 0xffffffff\n    return( murmur3(data, seed=seed) % (nFilterBytes * 8) )\n```\n\nWe setup our hash function template using the formula and 0xfba4c795 constant set in [BIP37](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki). Note that we limit the size of the seed to four bytes and that we're returning the result of the hash modulo the size of the filter in bits.\n\n``` python\ndata_to_hash = \"019f5b01d4195ecbc9398fbf3c3b1fa9\" \\\n               + \"bb3183301d7a1fb3bd174fcfa40a2b65\"\ndata_to_hash = data_to_hash.decode(\"hex\")\n```\n\nFor the data to add to the filter, we're adding a <<glossary:TXID>>. Note that the TXID is in <<glossary:internal byte order>>.\n\n``` python\nprint \"                             Filter (As Bits)\"\nprint \"nHashNum   nIndex   Filter   0123456789abcdef\"\nprint \"~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~\"\nfor nHashNum in range(nHashFuncs):\n    nIndex = bloom_hash(nHashNum, data_to_hash)\n\n    ## Set the bit at nIndex to 1\n    vData[nIndex] = True\n\n    ## Debug: print current state\n    print '      {0:2}      {1:2}     {2}   {3}'.format(\n        nHashNum,\n        hex(int(nIndex)),\n        vData.tobytes().encode(\"hex\"),\n        vData.to01()\n    )\n\nprint\nprint \"Bloom filter:\", vData.tobytes().encode(\"hex\")\n```\n\nNow we use the hash function template to run a slightly different hash function for *nHashFuncs* times. The result of each function being run on the transaction is used as an index number: the bit at that index is set to 1. We can see this in the printed debugging output:\n\n``` text\n                             Filter (As Bits)\nnHashNum   nIndex   Filter   0123456789abcdef\n~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~\n       0      0x7     8000   0000000100000000\n       1      0x9     8002   0000000101000000\n       2      0xa     8006   0000000101100000\n       3      0x2     8406   0010000101100000\n       4      0xb     840e   0010000101110000\n       5      0x5     a40e   0010010101110000\n       6      0x0     a50e   1010010101110000\n       7      0x8     a50f   1010010111110000\n       8      0x5     a50f   1010010111110000\n       9      0x8     a50f   1010010111110000\n      10      0x4     b50f   1010110111110000\n\nBloom filter: b50f\n```\n\nNotice that in iterations 8 and 9, the filter did not change because the corresponding bit was already set in a previous iteration (5 and 7, respectively).  This is a normal part of <<glossary:bloom filter>> operation.\n\nWe only added one element to the filter above, but we could repeat the process with additional elements and continue to add them to the same filter. (To maintain the same false-positive rate, you would need a larger filter size as computed earlier.)\n\nNote: for a more optimized Python implementation with fewer external dependencies, see [python-bitcoinlib's](https://github.com/petertodd/python-bitcoinlib) bloom filter module which is based directly on Bitcoin Core's C++ implementation.\n\nUsing the [`filterload` message](core-ref-p2p-network-control-messages#section-filterload) format, the complete filter created above would be the binary form of the annotated hexdump shown below:\n\n``` text\n02 ......... Filter bytes: 2\nb50f ....... Filter: 1010 1101 1111 0000\n0b000000 ... nHashFuncs: 11\n00000000 ... nTweak: 0/none\n00 ......... nFlags: BLOOM_UPDATE_NONE\n```", 
 "link_external": false, 
 "body_html": "<div class=\"magic-block-textarea\"><p>In this section, we&#39;ll use variable names that correspond to the field names in the <a href=\"core-ref-p2p-network-control-messages#section-filterload\"><code>filterload</code> message documentation</a>. Each code block precedes the paragraph describing it.</p>\n<pre><code class=\"lang-python\"><span class='cm-s-neo'><span class=\"cm-comment\">#!&#47;usr&#47;bin&#47;env python</span>\n\n<span class=\"cm-variable\">BYTES_MAX</span> <span class=\"cm-operator\">=</span> <span class=\"cm-number\">36000</span>\n<span class=\"cm-variable\">FUNCS_MAX</span> <span class=\"cm-operator\">=</span> <span class=\"cm-number\">50</span>\n\n<span class=\"cm-variable\">nFlags</span> <span class=\"cm-operator\">=</span> <span class=\"cm-number\">0</span></span>\n</code></pre>\n<p>We start by setting some maximum values defined in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\">BIP37</a>: the maximum number of bytes allowed in a filter and the maximum number of hash functions used to hash each piece of data.  We also set nFlags to zero, indicating we don&#39;t want the remote node to update the filter for us. (We won&#39;t use nFlags again in the sample program, but real programs will need to use it.)</p>\n<pre><code class=\"lang-python\"><span class='cm-s-neo'><span class=\"cm-variable\">n</span> <span class=\"cm-operator\">=</span> <span class=\"cm-number\">1</span>\n<span class=\"cm-variable\">p</span> <span class=\"cm-operator\">=</span> <span class=\"cm-number\">0.0001</span></span>\n</code></pre>\n<p>We define the number (n) of elements we plan to insert into the filter and the false positive rate (p) we want to help protect our privacy. For this example, we will set <em>n</em> to one element and <em>p</em> to a rate of 1-in-10,000 to produce a small and precise filter for illustration purposes. In actual use, your filters will probably be much larger.</p>\n<pre><code class=\"lang-python\"><span class='cm-s-neo'><span class=\"cm-keyword\">from</span> <span class=\"cm-variable\">math</span> <span class=\"cm-keyword\">import</span> <span class=\"cm-variable\">log</span>\n<span class=\"cm-variable\">nFilterBytes</span> <span class=\"cm-operator\">=</span> <span class=\"cm-builtin\">int</span>(<span class=\"cm-builtin\">min</span>((<span class=\"cm-operator\">-</span><span class=\"cm-number\">1</span> <span class=\"cm-operator\">&#47;</span> <span class=\"cm-variable\">log</span>(<span class=\"cm-number\">2</span>)<span class=\"cm-operator\">**</span><span class=\"cm-number\">2</span> <span class=\"cm-operator\">*</span> <span class=\"cm-variable\">n</span> <span class=\"cm-operator\">*</span> <span class=\"cm-variable\">log</span>(<span class=\"cm-variable\">p</span>)) <span class=\"cm-operator\">&#47;</span> <span class=\"cm-number\">8</span>, <span class=\"cm-variable\">BYTES_MAX</span>))\n<span class=\"cm-variable\">nHashFuncs</span> <span class=\"cm-operator\">=</span> <span class=\"cm-builtin\">int</span>(<span class=\"cm-builtin\">min</span>(<span class=\"cm-variable\">nFilterBytes</span> <span class=\"cm-operator\">*</span> <span class=\"cm-number\">8</span> <span class=\"cm-operator\">&#47;</span> <span class=\"cm-variable\">n</span> <span class=\"cm-operator\">*</span> <span class=\"cm-variable\">log</span>(<span class=\"cm-number\">2</span>), <span class=\"cm-variable\">FUNCS_MAX</span>))\n\n<span class=\"cm-keyword\">from</span> <span class=\"cm-variable\">bitarray</span> <span class=\"cm-keyword\">import</span> <span class=\"cm-variable\">bitarray</span>  <span class=\"cm-comment\"># from pypi.python.org&#47;pypi&#47;bitarray</span>\n<span class=\"cm-variable\">vData</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">nFilterBytes</span> <span class=\"cm-operator\">*</span> <span class=\"cm-number\">8</span> <span class=\"cm-operator\">*</span> <span class=\"cm-variable\">bitarray</span>(<span class=\"cm-string\">'0'</span>, <span class=\"cm-variable\">endian</span><span class=\"cm-operator\">=</span><span class=\"cm-string\">\"little\"</span>)</span>\n</code></pre>\n<p>Using the formula described in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\">BIP37</a>, we calculate the ideal size of the filter (in bytes) and the ideal number of hash functions to use. Both are truncated down to the nearest whole number and both are also constrained to the maximum values we defined earlier. The results of this particular fixed computation are 2 filter bytes and 11 hash functions. We then use <em>nFilterBytes</em> to create a little-endian bit array of the appropriate size.</p>\n<pre><code class=\"lang-python\"><span class='cm-s-neo'><span class=\"cm-variable\">nTweak</span> <span class=\"cm-operator\">=</span> <span class=\"cm-number\">0</span></span>\n</code></pre>\n<p>We also should choose a value for <em>nTweak</em>.  In this case, we&#39;ll simply use zero.</p>\n<pre><code class=\"lang-python\"><span class='cm-s-neo'><span class=\"cm-keyword\">import</span> <span class=\"cm-variable\">pyhash</span>  <span class=\"cm-comment\"># from https:&#47;&#47;github.com&#47;flier&#47;pyfasthash</span>\n<span class=\"cm-variable\">murmur3</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">pyhash</span>.<span class=\"cm-property\">murmur3_32</span>()\n\n<span class=\"cm-keyword\">def</span> <span class=\"cm-def\">bloom_hash</span>(<span class=\"cm-variable\">nHashNum</span>, <span class=\"cm-variable\">data</span>):\n    <span class=\"cm-variable\">seed</span> <span class=\"cm-operator\">=</span> (<span class=\"cm-variable\">nHashNum</span> <span class=\"cm-operator\">*</span> <span class=\"cm-number\">0xfba4c795</span> <span class=\"cm-operator\">+</span> <span class=\"cm-variable\">nTweak</span>) <span class=\"cm-operator\">&amp;</span> <span class=\"cm-number\">0xffffffff</span>\n    <span class=\"cm-keyword\">return</span>( <span class=\"cm-variable\">murmur3</span>(<span class=\"cm-variable\">data</span>, <span class=\"cm-variable\">seed</span><span class=\"cm-operator\">=</span><span class=\"cm-variable\">seed</span>) <span class=\"cm-operator\">%</span> (<span class=\"cm-variable\">nFilterBytes</span> <span class=\"cm-operator\">*</span> <span class=\"cm-number\">8</span>) )</span>\n</code></pre>\n<p>We setup our hash function template using the formula and 0xfba4c795 constant set in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki\">BIP37</a>. Note that we limit the size of the seed to four bytes and that we&#39;re returning the result of the hash modulo the size of the filter in bits.</p>\n<pre><code class=\"lang-python\"><span class='cm-s-neo'><span class=\"cm-variable\">data_to_hash</span> <span class=\"cm-operator\">=</span> <span class=\"cm-string\">\"019f5b01d4195ecbc9398fbf3c3b1fa9\"</span> \\\n               <span class=\"cm-operator\">+</span> <span class=\"cm-string\">\"bb3183301d7a1fb3bd174fcfa40a2b65\"</span>\n<span class=\"cm-variable\">data_to_hash</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">data_to_hash</span>.<span class=\"cm-property\">decode</span>(<span class=\"cm-string\">\"hex\"</span>)</span>\n</code></pre>\n<p>For the data to add to the filter, we&#39;re adding a &lt;&lt;glossary:TXID&gt;&gt;. Note that the TXID is in &lt;&lt;glossary:internal byte order&gt;&gt;.</p>\n<pre><code class=\"lang-python\"><span class='cm-s-neo'><span class=\"cm-builtin\">print</span> <span class=\"cm-string\">\"                             Filter (As Bits)\"</span>\n<span class=\"cm-builtin\">print</span> <span class=\"cm-string\">\"nHashNum   nIndex   Filter   0123456789abcdef\"</span>\n<span class=\"cm-builtin\">print</span> <span class=\"cm-string\">\"~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~\"</span>\n<span class=\"cm-keyword\">for</span> <span class=\"cm-variable\">nHashNum</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-builtin\">range</span>(<span class=\"cm-variable\">nHashFuncs</span>):\n    <span class=\"cm-variable\">nIndex</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">bloom_hash</span>(<span class=\"cm-variable\">nHashNum</span>, <span class=\"cm-variable\">data_to_hash</span>)\n\n    <span class=\"cm-comment\">## Set the bit at nIndex to 1</span>\n    <span class=\"cm-variable\">vData</span>[<span class=\"cm-variable\">nIndex</span>] <span class=\"cm-operator\">=</span> <span class=\"cm-keyword\">True</span>\n\n    <span class=\"cm-comment\">## Debug: print current state</span>\n    <span class=\"cm-builtin\">print</span> <span class=\"cm-string\">'      {0:2}      {1:2}     {2}   {3}'</span>.<span class=\"cm-property\">format</span>(\n        <span class=\"cm-variable\">nHashNum</span>,\n        <span class=\"cm-builtin\">hex</span>(<span class=\"cm-builtin\">int</span>(<span class=\"cm-variable\">nIndex</span>)),\n        <span class=\"cm-variable\">vData</span>.<span class=\"cm-property\">tobytes</span>().<span class=\"cm-property\">encode</span>(<span class=\"cm-string\">\"hex\"</span>),\n        <span class=\"cm-variable\">vData</span>.<span class=\"cm-property\">to01</span>()\n    )\n\n<span class=\"cm-builtin\">print</span>\n<span class=\"cm-builtin\">print</span> <span class=\"cm-string\">\"Bloom filter:\"</span>, <span class=\"cm-variable\">vData</span>.<span class=\"cm-property\">tobytes</span>().<span class=\"cm-property\">encode</span>(<span class=\"cm-string\">\"hex\"</span>)</span>\n</code></pre>\n<p>Now we use the hash function template to run a slightly different hash function for <em>nHashFuncs</em> times. The result of each function being run on the transaction is used as an index number: the bit at that index is set to 1. We can see this in the printed debugging output:</p>\n<pre><code class=\"lang-text\">                             Filter (As Bits)\nnHashNum   nIndex   Filter   0123456789abcdef\n~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~\n       0      0x7     8000   0000000100000000\n       1      0x9     8002   0000000101000000\n       2      0xa     8006   0000000101100000\n       3      0x2     8406   0010000101100000\n       4      0xb     840e   0010000101110000\n       5      0x5     a40e   0010010101110000\n       6      0x0     a50e   1010010101110000\n       7      0x8     a50f   1010010111110000\n       8      0x5     a50f   1010010111110000\n       9      0x8     a50f   1010010111110000\n      10      0x4     b50f   1010110111110000\n\nBloom filter: b50f\n</code></pre>\n<p>Notice that in iterations 8 and 9, the filter did not change because the corresponding bit was already set in a previous iteration (5 and 7, respectively).  This is a normal part of &lt;&lt;glossary:bloom filter&gt;&gt; operation.</p>\n<p>We only added one element to the filter above, but we could repeat the process with additional elements and continue to add them to the same filter. (To maintain the same false-positive rate, you would need a larger filter size as computed earlier.)</p>\n<p>Note: for a more optimized Python implementation with fewer external dependencies, see <a href=\"https://github.com/petertodd/python-bitcoinlib\">python-bitcoinlib&#39;s</a> bloom filter module which is based directly on Bitcoin Core&#39;s C++ implementation.</p>\n<p>Using the <a href=\"core-ref-p2p-network-control-messages#section-filterload\"><code>filterload</code> message</a> format, the complete filter created above would be the binary form of the annotated hexdump shown below:</p>\n<pre><code class=\"lang-text\">02 ......... Filter bytes: 2\nb50f ....... Filter: 1010 1101 1111 0000\n0b000000 ... nHashFuncs: 11\n00000000 ... nTweak: 0&#x2F;none\n00 ......... nFlags: BLOOM_UPDATE_NONE\n</code></pre>\n\n</div>", 
 "user": "5b8400d7185d5e00036dcc3b", 
 "isReference": false, 
 "slug": "core-examples-p2p-network-creating-a-bloom-filter", 
 "link_url": "", 
 "isApi": false, 
 "project": "5daf2e65f4109c0040fd51e1", 
 "__v": 1, 
 "_id": "5db1ba63ff6cc8005f710883", 
 "order": 0, 
 "updates": []
}