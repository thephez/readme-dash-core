Complete Python script demonstrating the [Creating](core-examples-p2p-network-creating-a-bloom-filter)/[Evaluating](core-examples-p2p-network-evaluating-a-bloom-filter) bloom filter examples (available [here](https://gist.github.com/dash-docs/5d63f095352a717f90d41a5e7fbbdac1#file-bloom_filter_example-py)):
[block:code]
{
  "codes": [
    {
      "code": "#!/usr/bin/env python\nfrom math import log\nfrom bitarray import bitarray  # from pypi.python.org/pypi/bitarray\nimport pyhash  # from https://github.com/flier/pyfasthash\n\n# Based on BIP-37\n# https://github.com/QuantumExplorer/bips/blob/master/bip-0037.mediawiki\n\n# Defined in bloom.h\n# https://github.com/dashpay/dash/blob/master/src/bloom.h#L19-#L20\nMAX_BLOOM_FILTER_SIZE = 36000\nMAX_HASH_FUNCS = 50\n\n# Set of flags that control how matched items are added to the filter (per BIP-37)\n# https://github.com/dashpay/dash/blob/master/src/bloom.h#L26\nnFlags = 0\n\nnElements = 1 # Number of elements\nnFPRate = 0.0001 # False positive rate\n\nnFilterBytes = int(min((-1 / log(2)**2 * nElements * log(nFPRate)) / 8, MAX_BLOOM_FILTER_SIZE))\n\n# Calculate the number of hash functions to use in the filter\n# Limit the maximum number to 50 per BIP-37\nnHashFuncs = int(min(nFilterBytes * 8 / nElements * log(2), MAX_HASH_FUNCS))\n\nmurmur3 = pyhash.murmur3_32()\n\nTEST_TXID = \"019f5b01d4195ecbc9398fbf3c3b1fa9bb3183301d7a1fb3bd174fcfa40a2b65\"\n\ndef bloom_hash(nHashNum, data):\n    seed = (nHashNum * 0xfba4c795 + nTweak) & 0xffffffff\n    return( murmur3(data, seed=seed) % (nFilterBytes * 8) )\n\n\n# Bloom Filter creation\ndef create_filter(nTweak):\n    print('Creating bloom filter')\n    vData = nFilterBytes * 8 * bitarray('0', endian=\"little\")\n\n    data_to_hash = TEST_TXID\n    data_to_hash = data_to_hash.decode(\"hex\")\n\n    print('Filter bytes: {}; Hash functions: {}'.format(nFilterBytes, nHashFuncs))\n\n    print(\"                             Filter (As Bits)\")\n    print(\"nHashNum   nIndex   Filter   0123456789abcdef\")\n    print(\"~~~~~~~~   ~~~~~~   ~~~~~~   ~~~~~~~~~~~~~~~~\")\n    for nHashNum in range(nHashFuncs):\n        nIndex = bloom_hash(nHashNum, data_to_hash)\n\n        ## Set the bit at nIndex to 1\n        vData[nIndex] = True\n\n        ## Debug: print current state\n        print('      {0:2}      {1:2}     {2}   {3}'.format(\n            nHashNum,\n            hex(int(nIndex)),\n            vData.tobytes().encode(\"hex\"),\n            vData.to01()\n        ))\n\n    print('Bloom filter: {}\\n'.format(vData.tobytes().encode(\"hex\")))\n\n\n# Bloom Filter evaluation\ndef evaluate_filter():\n    print('Evaluating bloom filter')\n    vData = bitarray(endian='little')\n    vData.frombytes(\"b50f\".decode(\"hex\"))\n    nHashFuncs = 11\n    nTweak = 0\n    nFlags = 0\n\n    def contains(nHashFuncs, data_to_hash):\n        for nHashNum in range(nHashFuncs):\n            ## bloom_hash as defined in previous section\n            nIndex = bloom_hash(nHashNum, data_to_hash)\n\n            if vData[nIndex] != True:\n                print(\"MATCH FAILURE: Index {0} not set in {1}\\n\".format(\n                    hex(int(nIndex)),\n                    vData.to01()\n                ))\n                return False\n        print(\"MATCH SUCCESS\\n\")\n\n    ## Test 1: Same TXID as previously added to filter\n    data_to_hash = TEST_TXID\n    print('\\nChecking: {}'.format(data_to_hash))\n    data_to_hash = data_to_hash.decode(\"hex\")\n    contains(nHashFuncs, data_to_hash)\n\n    ## Test 2: Arbitrary string\n    data_to_hash = \"1/10,000 chance this ASCII string will match\"\n    print('Checking: {}'.format(data_to_hash))\n    contains(nHashFuncs, data_to_hash)\n\n\n# Tweak is a random value added to the seed value in the hash function\n# used by the bloom filter\nnTweak = 0\n\ncreate_filter(nTweak)\nevaluate_filter()",
      "language": "python"
    }
  ]
}
[/block]